install.packages("TinyTex")
corrplot(correlacoes, method = "color", type = "lower",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Matriz de Correlação", mar = c(0, 0, 1, 0),
cl.pos = "b", col = corrplot::COL2("RdYlBu"))
corrplot(correlacoes, method = "color", type = "lower",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Matriz de Correlação", mar = c(0, 0, 1, 0),
cl.pos = "b", col = corrplot::COL2("RdYlBu"))
library(car)
library(carData)
library(corrplot)
library(dplyr)
library(ggplot2)
library(lmtest)
library(pwr)
library(tidyr)
relatorio1 <- read.csv("relatorio1.csv")
relatorio2 <- read.csv("relatorio2.csv")
dadoscombinados <- merge(relatorio1, relatorio2, by = "id")
# Visualizar cabeçalho para conferir se a extração foi correta:
head(dadoscombinados)
#contar quantas entradas em 'dadoscombinados' tem campos vazios
sum(is.na(dadoscombinados))
#criar novo conjunto de dados retirando campos vazios de 'dadoscombinados'
dados_trata_NA <- tidyr::drop_na(dadoscombinados)
#contar quantas entradas tem campos vazios no novo conjunto de dados criado (verificar se é 0!)
sum(is.na(dados_trata_NA))
summary(dados_trata_NA)
# Contar os valores negativos na variável custo_frete
valores_negativos <- sum(dados_trata_NA$custo_frete < 0)
cat("Número de valores negativos em custo_frete:", valores_negativos, "\n")
# Excluir os valores negativos do dataframe
dados_trata_NA_nega <- dados_trata_NA[dados_trata_NA$custo_frete >= 0, ]
# Confirmar a exclusão
cat("Dimensão do dataframe após exclusão:", dim(dados_trata_NA_nega), "\n")
# Variáveis do dataframe
variaveis <- c("custo_frete", "distancia_km", "peso_carga_kg", "consumo_combustivel_kml", "temperatura_ambiente", "hora_envio")
# Função para identificar outliers (3 desvios padrão)
identificar_outliers <- function(data, variaveis) {
outliers_list <- list()
# Loop por cada variável especificada
for (coluna in variaveis) {
media <- mean(data[[coluna]], na.rm = TRUE)
desvio_padrao <- sd(data[[coluna]], na.rm = TRUE)
# Identificar os outliers
outliers <- data[
data[[coluna]] < (media - 3 * desvio_padrao) |
data[[coluna]] > (media + 3 * desvio_padrao),
coluna,
drop = FALSE
]
# Armazenar os outliers
outliers_list[[coluna]] <- outliers
}
return(outliers_list)
}
# Identificar os outliers antes do tratamento
outliers_antes <- identificar_outliers(dados_trata_NA_nega, variaveis)
# Remover os outliers do dataframe
remover_outliers <- function(data, variaveis) {
for (coluna in variaveis) {
media <- mean(data[[coluna]], na.rm = TRUE)
desvio_padrao <- sd(data[[coluna]], na.rm = TRUE)
# Filtrar os valores dentro de 3 desvios padrão
data <- data[
data[[coluna]] >= (media - 3 * desvio_padrao) &
data[[coluna]] <= (media + 3 * desvio_padrao),
, drop = FALSE
]
}
return(data)
}
# Aplicar o tratamento de outliers
dados_trata_final <- remover_outliers(dados_trata_NA_nega, variaveis)
# Identificar os outliers depois do tratamento (deve ser vazio)
outliers_depois <- identificar_outliers(dados_trata_final, variaveis)
# Exibir os outliers antes e depois do tratamento
cat("Outliers antes do tratamento:\n")
print(outliers_antes)
cat("\nOutliers depois do tratamento:\n")
print(outliers_depois)
# Função para criar boxplots no RStudio (dados antes do tratamento)
criar_boxplots_antes <- function(data_antes, variaveis) {
for (coluna in variaveis) {
# Criar dataframe para a variável
data_plot <- data.frame(
Valor = data_antes[[coluna]],
Variavel = coluna
)
# Gerar o boxplot
print(
ggplot(data_plot, aes(x = Variavel, y = Valor)) +
geom_boxplot(outlier.color = "red", outlier.size = 2, fill = "skyblue") +
labs(title = paste("Boxplot Antes do Tratamento -", coluna),
x = "Variável",
y = "Valores") +
theme_minimal()
)
}
}
# Chamar a função para criar e visualizar os boxplots
criar_boxplots_antes(dados_trata_NA_nega, variaveis)
summary(dados_trata_final)
# Matriz de correlações
correlacoes <- cor(dados_trata_final[, c("custo_frete", "distancia_km", "peso_carga_kg","consumo_combustivel_kml", "temperatura_ambiente", "hora_envio")])
print(correlacoes)
corrplot(correlacoes, method = "color", type = "lower",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Matriz de Correlação", mar = c(0, 0, 1, 0),
cl.pos = "b", col = corrplot::COL2("RdYlBu"))
# Ajustar o modelo de regressão
modelo <- lm(custo_frete ~ distancia_km + peso_carga_kg + consumo_combustivel_kml +
temperatura_ambiente + hora_envio, data = dados_trata_final)
# Resumo do modelo
summary(modelo)
# ANOVA do modelo
anova(modelo)
# Ajustar o modelo de regressão
modelo <- lm(custo_frete ~ distancia_km + peso_carga_kg + consumo_combustivel_kml +
temperatura_ambiente + hora_envio, data = dados_trata_final)
# Resumo do modelo
summary(modelo)
# ANOVA do modelo
anova(modelo)
library(car)
library(carData)
library(corrplot)
library(dplyr)
library(ggplot2)
library(lmtest)
library(pwr)
library(tidyr)
relatorio1 <- read.csv("relatorio1.csv")
relatorio2 <- read.csv("relatorio2.csv")
dadoscombinados <- merge(relatorio1, relatorio2, by = "id")
# Visualizar cabeçalho para conferir se a extração foi correta:
head(dadoscombinados)
#contar quantas entradas em 'dadoscombinados' tem campos vazios
sum(is.na(dadoscombinados))
#criar novo conjunto de dados retirando campos vazios de 'dadoscombinados'
dados_trata_NA <- tidyr::drop_na(dadoscombinados)
#contar quantas entradas tem campos vazios no novo conjunto de dados criado (verificar se é 0!)
sum(is.na(dados_trata_NA))
summary(dados_trata_NA)
# Contar os valores negativos na variável custo_frete
valores_negativos <- sum(dados_trata_NA$custo_frete < 0)
cat("Número de valores negativos em custo_frete:", valores_negativos, "\n")
# Excluir os valores negativos do dataframe
dados_trata_NA_nega <- dados_trata_NA[dados_trata_NA$custo_frete >= 0, ]
# Confirmar a exclusão
cat("Dimensão do dataframe após exclusão:", dim(dados_trata_NA_nega), "\n")
# Variáveis do dataframe
variaveis <- c("custo_frete", "distancia_km", "peso_carga_kg", "consumo_combustivel_kml", "temperatura_ambiente", "hora_envio")
# Função para identificar outliers (3 desvios padrão)
identificar_outliers <- function(data, variaveis) {
outliers_list <- list()
# Loop por cada variável especificada
for (coluna in variaveis) {
media <- mean(data[[coluna]], na.rm = TRUE)
desvio_padrao <- sd(data[[coluna]], na.rm = TRUE)
# Identificar os outliers
outliers <- data[
data[[coluna]] < (media - 3 * desvio_padrao) |
data[[coluna]] > (media + 3 * desvio_padrao),
coluna,
drop = FALSE
]
# Armazenar os outliers
outliers_list[[coluna]] <- outliers
}
return(outliers_list)
}
# Identificar os outliers antes do tratamento
outliers_antes <- identificar_outliers(dados_trata_NA_nega, variaveis)
# Remover os outliers do dataframe
remover_outliers <- function(data, variaveis) {
for (coluna in variaveis) {
media <- mean(data[[coluna]], na.rm = TRUE)
desvio_padrao <- sd(data[[coluna]], na.rm = TRUE)
# Filtrar os valores dentro de 3 desvios padrão
data <- data[
data[[coluna]] >= (media - 3 * desvio_padrao) &
data[[coluna]] <= (media + 3 * desvio_padrao),
, drop = FALSE
]
}
return(data)
}
# Aplicar o tratamento de outliers
dados_trata_final <- remover_outliers(dados_trata_NA_nega, variaveis)
# Identificar os outliers depois do tratamento (deve ser vazio)
outliers_depois <- identificar_outliers(dados_trata_final, variaveis)
# Exibir os outliers antes e depois do tratamento
cat("Outliers antes do tratamento:\n")
print(outliers_antes)
cat("\nOutliers depois do tratamento:\n")
print(outliers_depois)
# Função para criar boxplots no RStudio (dados antes do tratamento)
criar_boxplots_antes <- function(data_antes, variaveis) {
for (coluna in variaveis) {
# Criar dataframe para a variável
data_plot <- data.frame(
Valor = data_antes[[coluna]],
Variavel = coluna
)
# Gerar o boxplot
print(
ggplot(data_plot, aes(x = Variavel, y = Valor)) +
geom_boxplot(outlier.color = "red", outlier.size = 2, fill = "skyblue") +
labs(title = paste("Boxplot Antes do Tratamento -", coluna),
x = "Variável",
y = "Valores") +
theme_minimal()
)
}
}
# Chamar a função para criar e visualizar os boxplots
criar_boxplots_antes(dados_trata_NA_nega, variaveis)
summary(dados_trata_final)
# Matriz de correlações
correlacoes <- cor(dados_trata_final[, c("custo_frete", "distancia_km", "peso_carga_kg","consumo_combustivel_kml", "temperatura_ambiente", "hora_envio")])
print(correlacoes)
corrplot(correlacoes, method = "color", type = "lower",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Matriz de Correlação", mar = c(0, 0, 1, 0),
cl.pos = "b", col = corrplot::COL2("RdYlBu"))
modelo_vif <- lm(custo_frete ~ distancia_km + peso_carga_kg + consumo_combustivel_kml + temperatura_ambiente + hora_envio, data = dados_trata_final)
vif(modelo_vif)
plot(modelo_vif$fitted.values, residuals(modelo_vif),
main = "Resíduos vs Valores Preditos",
xlab = "Valores Preditos", ylab = "Resíduos")
abline(h = 0, col = "red")
durbinWatsonTest(modelo_vif)
bptest(modelo_vif)
shapiro.test(residuals(modelo_vif))
#Gráfico Q-Q
residuos <- residuals(modelo_vif)
ggplot(data.frame(residuos), aes(sample = residuos)) +
stat_qq(color = "blue", size = 2) +  # Pontos do gráfico Q-Q
stat_qq_line(color = "red", linetype = "dashed", size = 1) +  # Linha de referência
labs(title = "Q-Q Plot dos Resíduos",
x = "Quantis Teóricos",
y = "Quantis dos Resíduos") +
theme_minimal()
amostra <- pwr.f2.test(u = 5, v = NULL, f2 = 0.15, sig.level = 0.05, power = 0.8)
print(amostra)
N <- 85.21+5+1
print(N)
# Ajustar o modelo de regressão
modelo <- lm(custo_frete ~ distancia_km + peso_carga_kg + consumo_combustivel_kml +
temperatura_ambiente + hora_envio, data = dados_trata_final)
# Resumo do modelo
summary(modelo)
# ANOVA do modelo
anova(modelo)
